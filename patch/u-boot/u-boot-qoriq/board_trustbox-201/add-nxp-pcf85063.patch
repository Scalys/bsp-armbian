commit 75ca3466e1067a49a80ce7d3f719efbdab4c04a8
Author: Siarhei Yasinski <siarhei.yasinski@sintecs.eu>
Date:   Wed Aug 31 10:47:42 2022 +0300

    drivers: Added support for NXP PCF85063 RTC

diff --git a/drivers/rtc/Kconfig b/drivers/rtc/Kconfig
index 2396327192..c8fd255e1d 100644
--- a/drivers/rtc/Kconfig
+++ b/drivers/rtc/Kconfig
@@ -111,6 +111,12 @@ config RTC_PCF8563
 	  If you say yes here you get support for the Philips PCF8563 RTC
 	  and compatible chips.
 
+config RTC_PCF85063
+	tristate "NXP PCF85063"
+	help
+	  If you say yes here you get support for the NXP PCF85063 RTC
+	  and compatible chips.
+
 config RTC_RV3028
 	bool "Enable RV3028 driver"
 	depends on DM_RTC
diff --git a/drivers/rtc/Makefile b/drivers/rtc/Makefile
index d621be6228..467b6e819a 100644
--- a/drivers/rtc/Makefile
+++ b/drivers/rtc/Makefile
@@ -42,6 +42,7 @@ obj-$(CONFIG_RTC_MV) += mvrtc.o
 obj-$(CONFIG_RTC_MX27) += mx27rtc.o
 obj-$(CONFIG_RTC_MXS) += mxsrtc.o
 obj-$(CONFIG_RTC_PCF8563) += pcf8563.o
+obj-$(CONFIG_RTC_PCF85063) += pcf85063.o
 obj-$(CONFIG_RTC_PCF2127) += pcf2127.o
 obj-$(CONFIG_RTC_PL031) += pl031.o
 obj-$(CONFIG_RTC_PT7C4338) += pt7c4338.o
diff --git a/drivers/rtc/pcf85063.c b/drivers/rtc/pcf85063.c
new file mode 100644
index 0000000000..07b54b615a
--- /dev/null
+++ b/drivers/rtc/pcf85063.c
@@ -0,0 +1,222 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * (C) Copyright 2001
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * Scalys, opensource@scalys.com
+ */
+
+/*
+ * Date & Time support for NXP PCF85063(TP) RTC
+ * reference pcf8563.c
+ */
+
+#include <common.h>
+#include <command.h>
+#include <dm.h>
+#include <log.h>
+#include <rtc.h>
+#include <i2c.h>
+
+/* Control and status registers */
+#define PCF85063_CONTROL_1_REG		0x0
+#define PCF85063_CONTROL_2_REG		0x1
+#define PCF85063_OFFSET_REG		0x2
+#define PCF85063_RAM_BYTE_REG		0x3
+
+/* Time and date registers */
+#define PCF85063_SECONDS_REG		0x4
+#define PCF85063_MINUTES_REG		0x5
+#define PCF85063_HOURS_REG		0x6
+#define PCF85063_DAYS_REG		0x7
+#define PCF85063_WEEKDAYS_REG		0x8
+#define PCF85063_MONTHS_REG		0x9
+#define PCF85063_YEARS_REG		0xA
+
+#if !CONFIG_IS_ENABLED(DM_RTC)
+static uchar rtc_read  (uchar reg);
+static void  rtc_write (uchar reg, uchar val);
+
+/* ------------------------------------------------------------------------- */
+
+int rtc_get (struct rtc_time *tmp)
+{
+	int rel = 0;
+	uchar sec, min, hour, mday, wday, mon_cent, year;
+
+	sec	= rtc_read (PCF85063_SECONDS_REG);
+	min	= rtc_read (PCF85063_MINUTES_REG);
+	hour	= rtc_read (PCF85063_HOURS_REG);
+	mday	= rtc_read (PCF85063_DAYS_REG);
+	wday	= rtc_read (PCF85063_WEEKDAYS_REG);
+	mon_cent= rtc_read (PCF85063_MONTHS_REG);
+	year	= rtc_read (PCF85063_YEARS_REG);
+
+	debug ( "Get RTC year: %02x mon/cent: %02x mday: %02x wday: %02x "
+		"hr: %02x min: %02x sec: %02x\n",
+		year, mon_cent, mday, wday,
+		hour, min, sec );
+
+	if (sec & 0x80) {
+		puts ("### Warning: RTC Low Voltage - date/time not reliable\n");
+		//rel = -1;
+	}
+
+	tmp->tm_sec  = bcd2bin (sec  & 0x7F);
+	tmp->tm_min  = bcd2bin (min  & 0x7F);
+	tmp->tm_hour = bcd2bin (hour & 0x3F);
+	tmp->tm_mday = bcd2bin (mday & 0x3F);
+	tmp->tm_mon  = bcd2bin (mon_cent & 0x1F);
+	tmp->tm_year = bcd2bin (year) + ((mon_cent & 0x80) ? 1900 : 2000);
+	tmp->tm_wday = bcd2bin (wday & 0x07);
+	tmp->tm_yday = 0;
+	tmp->tm_isdst= 0;
+
+	debug ( "Get DATE: %4d-%02d-%02d (wday=%d)  TIME: %2d:%02d:%02d\n",
+		tmp->tm_year, tmp->tm_mon, tmp->tm_mday, tmp->tm_wday,
+		tmp->tm_hour, tmp->tm_min, tmp->tm_sec);
+
+	return rel;
+}
+
+int rtc_set (struct rtc_time *tmp)
+{
+	uchar century;
+
+	debug ( "Set DATE: %4d-%02d-%02d (wday=%d)  TIME: %2d:%02d:%02d\n",
+		tmp->tm_year, tmp->tm_mon, tmp->tm_mday, tmp->tm_wday,
+		tmp->tm_hour, tmp->tm_min, tmp->tm_sec);
+
+	rtc_write (PCF85063_YEARS_REG, bin2bcd(tmp->tm_year % 100));
+
+	century = (tmp->tm_year >= 2000) ? 0 : 0x80;
+	rtc_write (PCF85063_MONTHS_REG, bin2bcd(tmp->tm_mon) | century);
+
+	rtc_write (PCF85063_WEEKDAYS_REG, bin2bcd(tmp->tm_wday));
+	rtc_write (PCF85063_DAYS_REG, bin2bcd(tmp->tm_mday));
+	rtc_write (PCF85063_HOURS_REG, bin2bcd(tmp->tm_hour));
+	rtc_write (PCF85063_MINUTES_REG, bin2bcd(tmp->tm_min ));
+	rtc_write (PCF85063_SECONDS_REG, bin2bcd(tmp->tm_sec ));
+
+	return 0;
+}
+
+void rtc_reset (void)
+{
+	/* clear all control & status registers */
+	rtc_write (PCF85063_CONTROL_1_REG, 0x00);
+	rtc_write (PCF85063_CONTROL_2_REG, 0x00);
+	rtc_write (PCF85063_OFFSET_REG, 0x00);
+	rtc_write (PCF85063_RAM_BYTE_REG, 0x00);
+
+	/* clear Voltage Low bit */
+	rtc_write (PCF85063_SECONDS_REG, rtc_read (PCF85063_SECONDS_REG) & 0x7F);
+}
+
+/* ------------------------------------------------------------------------- */
+
+static uchar rtc_read (uchar reg)
+{
+	return (i2c_reg_read (CONFIG_SYS_I2C_RTC_ADDR, reg));
+}
+
+static void rtc_write (uchar reg, uchar val)
+{
+	i2c_reg_write (CONFIG_SYS_I2C_RTC_ADDR, reg, val);
+}
+#else
+static int pcf85063_rtc_get(struct udevice *dev, struct rtc_time *tmp)
+{
+	int rel = 0;
+	uchar sec, min, hour, mday, wday, mon_cent, year;
+
+	sec	= dm_i2c_reg_read(dev, PCF85063_SECONDS_REG);
+	min	= dm_i2c_reg_read(dev, PCF85063_MINUTES_REG);
+	hour	= dm_i2c_reg_read(dev, PCF85063_HOURS_REG);
+	mday	= dm_i2c_reg_read(dev, PCF85063_DAYS_REG);
+	wday	= dm_i2c_reg_read(dev, PCF85063_WEEKDAYS_REG);
+	mon_cent = dm_i2c_reg_read(dev, PCF85063_MONTHS_REG);
+	year	= dm_i2c_reg_read(dev, PCF85063_YEARS_REG);
+
+	debug("Get RTC year: %02x mon/cent: %02x mday: %02x wday: %02x ",
+	      year, mon_cent, mday, wday);
+	debug("hr: %02x min: %02x sec: %02x\n",
+	      hour, min, sec);
+
+	if (sec & 0x80) {
+		puts("### Warning: RTC Low Voltage - date/time not reliable\n");
+		//rel = -1;
+	}
+
+	tmp->tm_sec = bcd2bin(sec & 0x7F);
+	tmp->tm_min = bcd2bin(min & 0x7F);
+	tmp->tm_hour = bcd2bin(hour & 0x3F);
+	tmp->tm_mday = bcd2bin(mday & 0x3F);
+	tmp->tm_mon = bcd2bin(mon_cent & 0x1F);
+	tmp->tm_year = bcd2bin(year) + ((mon_cent & 0x80) ? 1900 : 2000);
+	tmp->tm_wday = bcd2bin(wday & 0x07);
+	tmp->tm_yday = 0;
+	tmp->tm_isdst = 0;
+
+	debug("Get DATE: %4d-%02d-%02d (wday=%d)  TIME: %2d:%02d:%02d\n",
+	      tmp->tm_year, tmp->tm_mon, tmp->tm_mday, tmp->tm_wday,
+	      tmp->tm_hour, tmp->tm_min, tmp->tm_sec);
+
+	return rel;
+}
+
+static int pcf85063_rtc_set(struct udevice *dev, const struct rtc_time *tmp)
+{
+	uchar century;
+
+	debug("Set DATE: %4d-%02d-%02d (wday=%d)  TIME: %2d:%02d:%02d\n",
+	      tmp->tm_year, tmp->tm_mon, tmp->tm_mday, tmp->tm_wday,
+	      tmp->tm_hour, tmp->tm_min, tmp->tm_sec);
+
+	dm_i2c_reg_write(dev, PCF85063_YEARS_REG, bin2bcd(tmp->tm_year % 100));
+
+	century = (tmp->tm_year >= 2000) ? 0 : 0x80;
+	dm_i2c_reg_write(dev, PCF85063_MONTHS_REG, bin2bcd(tmp->tm_mon) | century);
+
+	dm_i2c_reg_write(dev, PCF85063_WEEKDAYS_REG, bin2bcd(tmp->tm_wday));
+	dm_i2c_reg_write(dev, PCF85063_DAYS_REG, bin2bcd(tmp->tm_mday));
+	dm_i2c_reg_write(dev, PCF85063_HOURS_REG, bin2bcd(tmp->tm_hour));
+	dm_i2c_reg_write(dev, PCF85063_MINUTES_REG, bin2bcd(tmp->tm_min));
+	dm_i2c_reg_write(dev, PCF85063_SECONDS_REG, bin2bcd(tmp->tm_sec));
+
+	return 0;
+}
+
+static int pcf85063_rtc_reset(struct udevice *dev)
+{
+	/* clear all control & status registers */
+	dm_i2c_reg_write(dev, PCF85063_CONTROL_1_REG, 0x00);
+	dm_i2c_reg_write(dev, PCF85063_CONTROL_2_REG, 0x00);
+	dm_i2c_reg_write(dev, PCF85063_OFFSET_REG, 0x00);
+	dm_i2c_reg_write(dev, PCF85063_RAM_BYTE_REG, 0x00);
+
+	/* clear Voltage Low bit */
+	dm_i2c_reg_write(dev, PCF85063_SECONDS_REG, dm_i2c_reg_read(dev, PCF85063_SECONDS_REG) & 0x7F);
+
+	return 0;
+}
+
+static const struct rtc_ops pcf85063_rtc_ops = {
+	.get = pcf85063_rtc_get,
+	.set = pcf85063_rtc_set,
+	.reset = pcf85063_rtc_reset,
+};
+
+static const struct udevice_id pcf85063_rtc_ids[] = {
+	{ .compatible = "nxp,pcf85063" },
+	{ .compatible = "nxp,pcf85063tp" },
+	{ }
+};
+
+U_BOOT_DRIVER(rtc_pcf85063) = {
+	.name   = "rtc-pcf85063",
+	.id     = UCLASS_RTC,
+	.of_match = pcf85063_rtc_ids,
+	.ops    = &pcf85063_rtc_ops,
+};
+#endif
